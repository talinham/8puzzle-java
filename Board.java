
//public class Board {

//}
import java.util.Arrays;
import java.util.Iterator;

class Tree {
	private Board root;
	
	private static  Board [] boardTreeArray = new Board[1000000]; // array of the tree generated by all nodes expanded to search
	// for the goal board; every board referred by idx
	 private static int trlength = 0; // length of boardTreeArray
		
	public void setTrLength (int length) {
		trlength = length;
	}
	public int getTrlength () {
		return trlength;
	}
	
	public void setBTA (Board br, int index)
	{
		boardTreeArray[index] = br;
	}
	public Board [] getBTA () {
		return boardTreeArray;
	}
	
	private int depth; // the depth of the tree
	private int idx; // Tree nodes (which is a Board) index
	private int step;
	public Tree () {
		root = null;
	}
	public void setRoot (Board b) {
		root = b;
	}
}

class boardArray {
	private Board [] ba;
	int number; // number of Boards in board array ba
}


public class Board {
	//private int[] goal = {2, 8, 3, 1, 6, 0, 7, 5, 4}; 
	private int[] goal = {1, 4, 8, 2, 5, 7, 3, 6, 0}; 
	private int[] loc = new int[9]; // locations of 1, 2, thru 8 (not 0) of the corresponding board.
	// For example, if board is {3, 1, 2, 7, 0, 4, 5, 8, 6}, then loc[board[]] is [4, 1, 2, 0, 5, 6, 8, 3, 7} 
	// since 0 is in location 4, 1 in location 1, 4 in location 5 etc.
	
	private Board parent; // the parent in the tree that expands to this node.
	// parent of root is nil
	private void setParent (Board p) {
		parent = p;
	}
	public  Board getParent () {
		return parent;
	}

	private  Board [] children = new Board [4]; // There can be 1 to 4 children for an expanded Board.
	private  int [] board = new int [9];
	private static int [] Hamming = new int[4]; // Hamming distance of the neighbors
	private int Ham; // Hamming distance of this node
	private static int [][] nbr  = new int [4][9]; // Define up to 4 neighbors
	private  int idx, step;  // idx is the index of this board in the btA.
	private int nonbr; // number of neighbors: should be 2, 3, or 4.
	public int getnbr () {
		return nonbr;
	}
	private static int bidx;
	private boolean expandable = false;

	private boolean foundGoal = false;
	private boolean [] childIsGoal = new boolean[4];
	public boolean getGoal () {
		return foundGoal;
	}
	boolean expanded = false; // This is true if the board is expanded 
		
	public Board(int [] tiles) {  // default constructor
		board = tiles;
	
	}
	
	public void setidx (int index)
	{
		idx = index;
	}
	
	public int getidx () {
		return idx;
	}
	
	public int[] getboard () {
		return board;
	}
	public void setExpandable (boolean bl) {
		expandable = bl;
		
	}
	public boolean getExpandable () {
		return expandable;
	}
	
	public int[] calLoc (int [] bd) // calculate the locations 
	{
		int [] myloc = new int[9];
		for (int i = 0; i < 9; i ++)
			for (int j = 0; j < 9; j ++)
				if (bd[j] == i)
					myloc [i] = j;
		
		return myloc;
	}
    public int hamming() // return number of blocks out of place only for 1 through 8, not for 0
    {
    	int count = 0;
    	int [] locMe = new int[9], locGoal = new int[9];
		locMe = calLoc (board);
		locGoal = calLoc (goal);
		for (int i = 1; i < 9; i ++)
		//	if (board[i] != (i+1))  // tile number is 1 to 8, corresponding to index 0 to 7.
			if (locMe[i] != locGoal[i])  // tile number is 1 to 8, corresponding to index 0 to 7.
				count++;
	  return count;
    }
    
	public int manhattan()  // return sum of Manhattan distances between blocks and goal
	{
		int  steps = 0;
		int count = 0;
		int [] locMe = new int[9], locGoal = new int[9];
		locMe = calLoc (board);
		locGoal = calLoc (goal);
		for (int i = 1; i < 9; i ++)
		{	
			steps += Math.abs(locMe[i]%3 -locGoal[i]%3); // vertical step
			steps += Math.abs(locMe[i]/3 -locGoal[i]/3); // horizontal step
			count += steps;
			steps = 0;			
		}
	
		return count;
	}
	public boolean equals (Object y )   // does this board equal y
	{
		return false;
	}
	
	
	public  Board []  findNbr () { // expand this Board node, idx is the index of board in BTR
	//	public static void  expand (int idx, Board [] bd) { // expand this Board node, idx is the index of board in BTR
		int i, j;
		boolean found = false;
		boolean perm = true;
		
		// Verify that  board is a permutation of 0, 1, .., through 8 (for 8 puzzle)
		int [] count = new int [9];
				
		for (i = 0; i < 9; i ++)
			for (j = 0; j < 9; j ++)
				if (board [j] == i)
					count [i] ++;
		
		for (i = 0; i < 9; i ++)
			if (count[i] !=1)
				perm = false;
		
		 if (!perm) {
			 System.out.println("Board data wrong");
			 for (i = 0; i < 9 ; i++)
				 System.out.print(board[i] + "  ");
			 System.out.println();
			 System.exit(1);
		 }
		 
		 // check if this board is goal
		 if (Arrays.equals(board, goal)) {
			 System.out.println("This board itself is the goal, no more work");
			 foundGoal = true;
			 System.exit(1);
		 }
		
		for (i = 0; i < 9; i++)
			if (board[i] == 0)
			{
				bidx = i;   // find the tile index of the blank (hole)
				break;
			}				
	    
		switch (bidx) {
		
		// 4 cases when blank is at the 4 corners. There are 2 neighbors.
		// However, 1 neighbor could be the parent.
			case 0:
			case 2:
			case 6:
			case 8:
		
			nbr[0] = Arrays.copyOf(board, board.length);
			nbr[1] = Arrays.copyOf(board, board.length);
			
			// The next 4 lines are different for case 0, 2, 6, or 8
			if (bidx == 0) {  // position 0 is next to p1 and p3
			nbr[0][1] = board[0]; // switch positions 0 and 1
			nbr[0][0] = board[1];
			
			nbr[1][3] = board[0]; // switch positions 0 and 3
			nbr[1][0] = board[3];
			}
			if (bidx == 2) { // position 2 is next to p1 and p5
			nbr[0][1] = board[2]; // switch positions 1 and 2
			nbr[0][2] = board[1];
			
			nbr[1][5] = board[2]; 
			nbr[1][2] = board[5];
			}			
			if (bidx == 6) {  // position 6 is next to p3 and p7
			nbr[0][6] = board[3]; // switch positions 3 and 6
			nbr[0][3] = board[6];
			
			nbr[1][6] = board[7]; // switch positions 6 and 7
			nbr[1][7] = board[6];
			}
			if (bidx == 8) { // position 8 is next to p5 and p7
			nbr[0][8] = board[5]; // switch positions 8 and 5
			nbr[0][5] = board[8];
			
			nbr[1][8] = board[7]; 
			nbr[1][7] = board[8];
			}
			// Next lines are the same for 0, 2, 6, 8
			nonbr = 2;
			Hamming[0] = calHamming(nbr[0]);
			Hamming[1] = calHamming(nbr[1]);
			
			// Check if goal found
			if (Arrays.equals(goal, nbr[0])) {
				System.out.println("Goal reached: case 0,2,6,8, nbr[0]");
				foundGoal = true;
			}
			if (Arrays.equals(goal, nbr[1])) {
				System.out.println("Goal reached: case 0,2,6,8, nbr[1]");
				foundGoal = true;
			}
			
			if (idx > 0)  // check if nbr[0] or nbr[1] is the parent of board: should be exactly one of them
			{				
				int parentid;
				parentid = parent.getidx();  // get parent ID	
				if (Arrays.equals(parent.getboard(),nbr[0])) {
					//System.out.println ("nbr[0] is the parent, nbr[1] is new child");			
					children [0] = new Board (nbr[1]);														 
				}	
				else if (Arrays.equals(parent.getboard(),nbr[1])) {
					//System.out.println ("nbr[1] is the parent, nbr[0] is new child");		
					children [0] = new Board (nbr[0]);					
				}
				else
					System.out.println ("Error! Neither nbr[1] nor nbr[0] is the parent");				
				// common code for children[0]
				nonbr = 1;
				children[0].setParent(this);
			//	children[0].idx = idx + 1;
				children[0].expandable = true;
			}
			else // (idx = 0) case for expansion at the start node. Both nodes are added to the BTA
			{  // Now if the two Hamming values are different, only the one with smaller
				// Hamming value will be added to BTR; otherwise both will be added, and both
				// will be expanded, processed, and searched by breadth first search				
				// Debugging code: debugger does NOT work well.
		
				children [0] = new Board (nbr[0]);												
				children [1] = new Board (nbr[1]);											
				
		//		children[0].idx = idx + 1;
			//	children[1].idx = idx + 2;
				nonbr = 2;	
				
				int min; // minimum
		
				min = Hamming[0];
				if (Hamming[1] < min)
					min = Hamming[1];
				
				for (i = 0; i < 2; i ++) {
					children [i].setParent(this);
					if (Hamming[i] == min) {
	
				        children[i].expandable = true;
					}
					else
						children[i].expandable = false;
				}							
				
			}
			
			break;
			
			// 4 cases when blank is at the center of 4 sides
			case 1:
			case 3:
			case 5:
			case 7: 
			
				// NOw there are 3 neighbors when moving the blank tile
			nbr[0] = Arrays.copyOf(board, board.length);
			nbr[1] = Arrays.copyOf(board, board.length);
			nbr[2] = Arrays.copyOf(board, board.length);
			
			// The next 6 lines are different for case 1, 3, 5, or 7
			if (bidx == 1) {  // position 1 is next to p0, p2, and p4
			nbr[0][1] = board[0]; // switch positions 0 and 1
			nbr[0][0] = board[1];
			
			nbr[1][1] = board[2]; // switch positions 1 and 2
			nbr[1][2] = board[1];
			
			nbr[2][1] = board[4]; // switch positions 1 and 4
			nbr[2][4] = board[1];
			}
			
			if (bidx == 3) {  // position 3 is next to p0, p4, and p6
				nbr[0][3] = board[0]; // switch positions 0 and 3
				nbr[0][0] = board[3];
				
				nbr[1][3] = board[4]; // switch positions 3 and 4
				nbr[1][4] = board[3];
				
				nbr[2][3] = board[6]; // switch positions 3 and 6
				nbr[2][6] = board[3];
				}
			
			if (bidx == 5) {  // position 5 is next to p2, p4, and p8
				nbr[0][5] = board[2]; // switch positions 5 and 2
				nbr[0][2] = board[5];
				
				nbr[1][5] = board[4]; // switch positions 5 and 4
				nbr[1][4] = board[5];
				
				nbr[2][5] = board[8]; // switch positions 5 and 8
				nbr[2][8] = board[5];
				}
			
			if (bidx == 7) {  // position 7 is next to p6, p4, and p8
				nbr[0][6] = board[7]; // switch positions 7 and 6
				nbr[0][7] = board[6];
				
				nbr[1][7] = board[4]; // switch positions 7 and 4
				nbr[1][4] = board[7];
				
				nbr[2][7] = board[8]; // switch positions 7 and 8
				nbr[2][8] = board[7];
				}
			
			// Next lines are the same for 1,3,5, and 7
				
				
			
				// Check if goal reached
				if (Arrays.equals(goal, nbr[0])) {
					System.out.println("Goal reached: case 1,3,5,7, nbr[0]");				
					foundGoal = true;
				}
				if (Arrays.equals(goal, nbr[1])) {
					System.out.println("Goal reached: case 1,3,5,7, nbr[1]");				
					foundGoal = true;
				}
				if (Arrays.equals(goal, nbr[2])) {
					System.out.println("Goal reached: case 1,3,5,7, nbr[2]");			
					foundGoal = true;
				}
				
				if (idx > 0)  // one of  nbr[0],  nbr[1], or nbr[2] is the parent of board: should be exactly one of them
				{				
			
					if (Arrays.equals(parent.getboard(),nbr[0])) {
							//System.out.println ("nbr[0] is the parent");
						// Compare Hamming values of nbr[1] and nbr[2]; either one or both will be expanded
							children [0] = new Board (nbr[1]);
							children [1] = new Board (nbr[2]);	
							Hamming[0] = calHamming(nbr[1]);
							Hamming[1] = calHamming(nbr[2]);
						}
					else if (Arrays.equals(parent.getboard(),nbr[1])) {
						//System.out.println ("nonbr = 3, nbr[1] is the parent");
						// Put nbr[0] in the states array, set its parent to k 
						children [0] = new Board (nbr[0]);
						children [1] = new Board (nbr[2]);	
						Hamming[0] = calHamming(nbr[0]);
						Hamming[1] = calHamming(nbr[2]);
					
					}
					else if (Arrays.equals(parent.getboard(),nbr[2])) {
						//System.out.println ("nbr[1] is the parent, nbr[2] is new child");
						// Put nbr[0] in the states array, set its parent to k 
						children [0] = new Board (nbr[0]);
						children [1] = new Board (nbr[1]);	
						Hamming[0] = calHamming(nbr[0]);
						Hamming[1] = calHamming(nbr[1]);
					}
					else
						System.out.println ("Error! Neither nbr[1] nor nbr[0] is the parent");
				
					nonbr = 2;  // two of 3 nbr's are valid
					int min; // minimum
					
					min = Hamming[0];
					if (Hamming[1] < min)
						min = Hamming[1];
			
							
					for (i = 0; i < 2; i ++) {						
						children [i].setParent(this);				
					
						if (Hamming[i] == min) {				
					        children[i].expandable = true;
						}
						else
							children[i].expandable = false;		
					}
				}  // if idx > 0
				else // (idx = 0) case for expansion at the start node
				{ // Compare the 3 Hamming values and find tne minimum
				  // If there is only one minimum, that one alone will be expanded
				  // If there are two or three minimum (all equal), then two or all three will be expanded
													
					children[0] = new Board (nbr[0]);
					children[1] = new Board (nbr[1]);
					children[2] = new Board (nbr[2]);			
					nonbr = 3;
					
					// Allocate boards for these three					
					
					int min; // minimum
					int [] minidx = new int[3];
					min = Hamming[0];
					if (Hamming[1] < min)
						min = Hamming[1];
					if (Hamming[2] < min)
						min = Hamming[2];
					
					for (i = 0; i < 3; i ++) {
						children [i].setParent(this);
						if (Hamming[i] == min) {
		//					minidx[i] = 1;  // find those Hamming equal to minimum, there can be 1, 2, or 3
					        children[i].expandable = true;
						}
						else
							children[i].expandable = false;
					}							
				}  // end of else idx = 0 case for 3 neighbors
			break;			
			case 4: // there are 4 neighbors				
			nbr[0] = Arrays.copyOf(board, board.length);
			nbr[1] = Arrays.copyOf(board, board.length);
			nbr[2] = Arrays.copyOf(board, board.length);
			nbr[3] = Arrays.copyOf(board, board.length);
			
			// position 4 is next to 1, 3, 5, and 7
			nbr[0][1] = board[4]; // switch positions 1 and 4
			nbr[0][4] = board[1];
			
			nbr[1][3] = board[4]; // switch positions 3 and 4
			nbr[1][4] = board[3];
			
			nbr[2][5] = board[4]; // switch positions 5 and 4
			nbr[2][4] = board[5];
			
			nbr[3][7] = board[4]; // switch positions 7 and 4
			nbr[3][4] = board[7];
			
			nonbr = 4;
			Hamming[0] = calHamming(nbr[0]);
			Hamming[1] = calHamming(nbr[1]);
			Hamming[2] = calHamming(nbr[2]);
			Hamming[3] = calHamming(nbr[3]);		
			
			// Check if goal reached
			if (Arrays.equals(goal, nbr[0])) {
				System.out.println("Goal reached: case 1,3,5,7, nbr[0]");
				foundGoal = true;
			}
			if (Arrays.equals(goal, nbr[1])) {
				System.out.println("Goal reached: case 1,3,5,7, nbr[1]");
				foundGoal = true;
			}
			if (Arrays.equals(goal, nbr[2])) {
				System.out.println("Goal reached: case 1,3,5,7, nbr[2]");
				foundGoal = true;
			}
			if (Arrays.equals(goal, nbr[3])) {
				System.out.println("Goal reached: case 1,3,5,7, nbr[3]");	
				foundGoal = true;
			}			
			if (idx > 0)  // one of  nbr[0],  nbr[1], nbr[2], or nbr[3] is the parent of board: should be exactly one of them
			{	
						
				if (Arrays.equals(parent.getboard(),nbr[0])) {
						//System.out.println ("nbr[0] is the parent");
					// Compare Hamming values of nbr[1] and nbr[2]; either one or both will be expanded
						children [0] = new Board (nbr[1]);
						children [1] = new Board (nbr[2]);			
						children [2] = new Board (nbr[3]);	
						Hamming[0] = calHamming(nbr[1]);
						Hamming[1] = calHamming(nbr[2]);
						Hamming[2] = calHamming(nbr[3]);
					
				}
				else if (Arrays.equals(parent.getboard(),nbr[1])) {
					//System.out.println ("nonbr = 3, nbr[1] is the parent");
					// Put nbr[0] in the states array, set its parent to k 
					children [0] = new Board (nbr[0]);
					children [1] = new Board (nbr[2]);	
					children [2] = new Board (nbr[3]);	
					Hamming[0] = calHamming(nbr[0]);
					Hamming[1] = calHamming(nbr[2]);
					Hamming[2] = calHamming(nbr[3]);
				}
				else if (Arrays.equals(parent.getboard(),nbr[2])) {
					//System.out.println ("nbr[1] is the parent, nbr[2] is new child");
					// Put nbr[0] in the states array, set its parent to k 
					children [0] = new Board (nbr[0]);
					children [1] = new Board (nbr[1]);	
					children [2] = new Board (nbr[3]);	
					Hamming[0] = calHamming(nbr[0]);
					Hamming[1] = calHamming(nbr[1]);
					Hamming[2] = calHamming(nbr[3]);
				}
				else if (Arrays.equals(parent.getboard(),nbr[3])) {
					//System.out.println ("nbr[3] is the parent");
					// Put nbr[0] in the states array, set its parent to k 
					children [0] = new Board (nbr[0]);
					children [1] = new Board (nbr[1]);	
					children [2] = new Board (nbr[2]);	
					Hamming[0] = calHamming(nbr[0]);
					Hamming[1] = calHamming(nbr[1]);
					Hamming[2] = calHamming(nbr[2]);
				}
				else
					System.out.println ("Error! None of nbr[0], nbr[1], nbr[2],nbr[3] the parent");
				
				
			//	children[0].idx = idx + 1;
			// children[1].idx = idx + 2;	
		//  children[2].idx = idx + 3;
				nonbr = 3;
				int min; // minimum
				
				min = Hamming[0];
				if (Hamming[1] < min)
					min = Hamming[1];
				if (Hamming[2] < min)
					min = Hamming[2];
				
				
				for (i = 0; i < 3; i ++) {
					children [i].setParent(this);
					if (Hamming[i] == min) {				
				        children[i].expandable = true;
					}
					else
						children[i].expandable = false;		
				}
			}  // if idx > 0
			else // (idx = 0) case for expansion at the start node
			{ // Compare the 4 Hamming values and find tne minimum
			  // If there is only one minimum, that one alone will be expanded
			  // If there are two or more minimum (all equal), then all of them three will be expanded
				children[0] = new Board (nbr[0]);
				children[1] = new Board (nbr[1]);
				children[2] = new Board (nbr[2]);
				children[3] = new Board (nbr[3]);
		//		children[0].idx = idx + 1;
			//	children[1].idx = idx + 2;
				//children[2].idx = idx + 3;
				// ildren[3].idx = idx + 4;
				nonbr = 4;
				
				int min; // minimum
			
				min = Hamming[0];
				if (Hamming[1] < min)
					min = Hamming[1];
				if (Hamming[2] < min)
					min = Hamming[2];
				if (Hamming[3] < min)
					min = Hamming[3];
				
				for (i = 0; i < 4; i ++) {
					children [i].setParent(this);
					if (Hamming[i] == min) {
	//					minidx[i] = 1;  // find those Hamming equal to minimum, there can be 1, 2, or 3
				        children[i].expandable = true;
					}
					else
						children[i].expandable = false;
				}							
			}  // end of else idx = 0 case for 3 neighbors
		break;	
		
		default: // none of cases 0 through 8, should not happen
			System.out.println("bidx value wrong:" + bidx);
		}  // end of switch
		// return the array of 1, 2, 3, or 4 boards
		/*
		System.out.println("Print children in findnbr");
		  for (i = 0 ; i < children.length; i ++)
			  if (children[i] != null)
			  {
				  System.out.println("Printing offspring with index: " + i);
				  children[i].print();
			  }
			  */
		return children;
	} // end of findNbr

	public  static int calHamming (int [] board ) {
		
	// Calculate the Hamming distance of board (of 9 titles) to see how many are
	//	different from the start state
		int count = 0;
		for (int i = 0; i < 8; i ++)
			if (board[i] != (i+1))
				count++;
	  return count;
	}
	// public String toString() // return a string representation of the board
	public void  print () { // print the board and pertinent info
		System.out.println("-------------");
		for (int i = 0; i < 9; i ++) {
			System.out.print("| " + board[i] + " ");
			if (i % 3 == 2)
				{
					System.out.println("|" );  // go to next line every 3 entries, to simulate 8 puzzle
					System.out.println("-------------");
				}
		}
		//System.out.println("H: " + hamming() + " M: " + manhattan() + " E:" + expandable +  " I:" + idx);
		
	} // end of print 
}
